---
title: '나의 위대한 모험: Next.js에서 PKCE와 Keycloak 길들이기'
date: 2025-08-01
draft: false
seo:
  title: '나의 위대한 모험: Next.js에서 PKCE와 Keycloak 길들이기'
  description: '한 솔로 프론트엔드 엔지니어의 고난과 승리의 이야기 - 클라이언트 사이드 렌더링 Next.js 프로젝트에서 Keycloak과 PKCE를 구현하며 무한 루프, 메모리를 잡아먹는 유령 세션과 싸워 승리한 여정'
  tag: '기술 경험담'
  type: 'tutorial'
  keywords: 'PKCE Keycloak Next.js SSO 인증 OAuth2 메모리 관리 디버깅'
---

## 도전: PKCE와 Keycloak SSO 구현하기

어느 날, 저라는 솔로 프론트엔드 엔지니어에게 엄청난 퀘스트가 주어졌습니다. 바로 PKCE (Proof Key for Code Exchange)라는 정체불명의 기술과 Keycloak 기반 SSO를, 그것도 하나가 아닌 두 개의 전체 클라이언트 사이드 렌더링(CSR) Next.js 프로젝트에 구현하라는 것이었죠. 제 첫 반응은요? "피케... 뭐라고요?" 😅 꼭 스타워즈에 나오는 드로이드 이름 같았어요.

이것은 제가 인증이라는 거친 땅을 헤쳐나가며 무한 루프, 메모리를 잡아먹는 유령 세션, 그리고 알 수 없는 에러들과 싸워온 여정의 기록입니다. 고군분투와 발견, 그리고 마침내 이뤄낸 꽤나 달콤한 승리의 이야기죠. 만약 새로운 과제 앞에서 막막함을 느껴본 개발자라면, 커피 한 잔 들고 제 이야기에 빠져보세요.

## 제1장: PKCE, 대체 정체가 뭐냐? 🤔

코드 한 줄을 짜기 전에, 저는 먼저 제 적을 알아야만 했습니다. 수많은 구글링 끝에, 마침내 그 개념을 이해할 수 있었죠.

쉽게 말해, PKCE는 우리 앱과 로그인 서버(제 경우엔 Keycloak) 사이의 비밀 악수 같은 겁니다. 브라우저 기반의 Next.js 앱(SPA)처럼 비밀을 안전하게 보관할 수 없는 앱들을 위해 설계되었죠.

핵심은 이렇습니다:

**앱의 약속**: 앱은 당신을 로그인 페이지로 보내기 전에, 비밀 값(code_verifier)과 그 비밀에 기반한 공개적인 약속(code_challenge)을 만듭니다. 그리고 Keycloak에 이 공개적인 약속을 보내며 말하죠. "곧 사용자 한 명 보낼게요. 그 사람이 임시 출입증을 들고 돌아오면, 제 비밀을 알려줘서 진짜 저라는 걸 증명할게요."

**사용자의 로그인**: 당신은 Keycloak으로 가서 아이디와 비밀번호를 입력하고, Keycloak은 임시 출입증(authorization_code)을 발급해 줍니다.

**비밀 악수**: 당신은 이 출입증을 들고 앱으로 돌아옵니다. 그러면 앱은 Keycloak에 다시 가서 말합니다. "저예요! 여기 임시 출입증이랑, 약속했던 제 비밀(code_verifier)이에요!"

**성공!** Keycloak은 이 비밀이 처음에 받았던 약속과 일치하는지 확인합니다. 일치한다면, 진짜 왕국의 열쇠(액세스 토큰)를 건네주고, 당신은 성공적으로 로그인됩니다!

이 악수 방식 덕분에, 혹시나 임시 출입증을 훔친 교활한 공격자가 있더라도 원래의 비밀을 모르기 때문에 사용할 수 없게 됩니다. 간단하지만 아주 영리한 보안 방식이죠.

## 제2장: 첫 시도 & 절망의 무한 루프 😫

새로운 지식으로 무장한 저는 코딩에 뛰어들었습니다. Keycloak을 설정하고, Next.js 환경을 구축하고, 초기화 코드를 작성했죠. 그리고 "로그인" 버튼을 클릭했습니다.

...그리고 저는 곧바로 절망의 무한 루프에 빠졌습니다.

페이지가 Keycloak으로 리디렉션되었다가, 다시 제 앱으로, 그리고 다시 Keycloak으로, 제가 개발자 도구를 열 틈도 없이 계속해서 반복되었습니다. 전형적인 초보자의 실수였지만, 정말 좌절스러운 경험이었죠. 제 앱과 Keycloak이 사용자 상태를 누가 처리할지를 두고 끝없는 말다툼을 벌이고 있었던 겁니다.

## 제3장: 코드의 핵심 - 실제 구현 🛠️

비슷한 퀘스트를 떠나는 동료 개발자들을 위해, 제 솔루션의 핵심이 된 코드들을 살펴보겠습니다. 이것을 제가 괴물을 길들이기 위해 사용한 마법서라고 생각하세요.

### 무대 설정: 환경 변수

먼저 Next.js 앱에게 Keycloak이 어디에 있는지 알려줘야 합니다. 프로젝트 루트에 `.env.local` 파일을 만들어서 설정합니다.

```bash
# .env.local

# Keycloak 서버 URL
NEXT_PUBLIC_KEYCLOAK_URL=http://localhost:8080/

# Keycloak에서 사용하는 'realm' 이름
NEXT_PUBLIC_KEYCLOAK_REALM=my-awesome-realm

# 프론트엔드 애플리케이션의 'Client ID'
NEXT_PUBLIC_KEYCLOAK_CLIENT_ID=my-nextjs-app
```

### 작전의 두뇌: Keycloak 초기화

여기서 keycloak-js 라이브러리를 설정합니다. 마법은 init 옵션에서 일어나며, 여기서 PKCE를 명시적으로 활성화합니다.

```typescript
// src/lib/keycloak-config.ts
import Keycloak from 'keycloak-js';

const keycloak = new Keycloak({
  url: process.env.NEXT_PUBLIC_KEYCLOAK_URL,
  realm: process.env.NEXT_PUBLIC_KEYCLOAK_REALM!,
  clientId: process.env.NEXT_PUBLIC_KEYCLOAK_CLIENT_ID!,
});

export const initializeKeycloak = async () => {
  try {
    const authenticated = await keycloak.init({
      // 'check-sso'는 사용자가 세션이 있으면 조용히 로그인을 시도합니다.
      // 이것이 불필요한 로그인 화면을 피하는 핵심입니다.
      onLoad: 'check-sso',

      // 이것이 가장 중요한 부분입니다! Keycloak에게 PKCE에 'S256' 방법을
      // 사용하라고 말하는 것입니다. 이것은 SHA-256입니다.
      pkceMethod: 'S256',

      // 조용한 인증 확인을 위한 페이지로, 메인 앱 창이
      // 다시 로드되는 것을 방지하는 데 도움이 됩니다.
      silentCheckSsoRedirectUri:
        window.location.origin + '/silent-check-sso.html',
    });
    console.log(`사용자는 ${authenticated ? '인증됨' : '인증되지 않음'}`);
    return authenticated;
  } catch (error) {
    console.error('Keycloak 초기화 실패', error);
    return false;
  }
};

export default keycloak;
```

### 앱의 심장: React Context

인증 상태(예: "사용자가 로그인했나?")를 앱 전체에서 사용할 수 있게 하려면, React Context가 완벽한 도구입니다.

```typescript
// src/contexts/AuthContext.tsx
'use client';

import React, { createContext, useContext, useEffect, useState } from 'react';
import { initializeKeycloak } from '@/lib/keycloak-config';
import keycloak from '@/lib/keycloak-config';

interface IAuthContext {
  isAuthenticated: boolean;
  isLoading: boolean;
  login: () => void;
  logout: () => void;
}

const AuthContext = createContext<IAuthContext | null>(null);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const initAuth = async () => {
      const authenticated = await initializeKeycloak();
      setIsAuthenticated(authenticated);
      setIsLoading(false);
    };
    initAuth();
  }, []);

  const login = () => keycloak.login();
  const logout = () => keycloak.logout();

  if (isLoading) {
    return <div>로딩 중...</div>; // 또는 멋진 스피너!
  }

  return (
    <AuthContext.Provider value={{ isAuthenticated, isLoading, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => useContext(AuthContext)!;
```

그러면 메인 layout.tsx에서 전체 애플리케이션을 이 AuthProvider로 감쌀 수 있습니다.

### 문지기: 보호된 라우트

마지막으로, 로그인한 사용자만 볼 수 있도록 특정 페이지를 보호하는 방법이 필요합니다. 간단한 컴포넌트가 문지기 역할을 할 수 있습니다.

```typescript
// src/components/AuthGuard.tsx
'use client';

import { useAuth } from '@/contexts/AuthContext';
import { useEffect } from 'react';

export const AuthGuard = ({ children }: { children: React.ReactNode }) => {
  const { isAuthenticated, login } = useAuth();

  useEffect(() => {
    // 사용자가 인증되지 않았다면, 로그인 플로우를 트리거합니다.
    if (!isAuthenticated) {
      login();
    }
  }, [isAuthenticated, login]);

  // 인증되었다면 페이지 내용을 보여줍니다.
  // 그렇지 않다면 로그인으로 리디렉션하는 동안 아무것도 보여주지 않습니다.
  return isAuthenticated ? <>{children}</> : null;
};
```

그러면 보호가 필요한 페이지에서 내용을 이 가드로 감싸면 됩니다:

```typescript
// src/app/dashboard/page.tsx
import { AuthGuard } from '@/components/AuthGuard';

export default function DashboardPage() {
  return (
    <AuthGuard>
      <h1>대시보드에 오신 것을 환영합니다!</h1>
      <p>멋지고 로그인한 사람들만 이것을 볼 수 있습니다.</p>
    </AuthGuard>
  );
}
```

이 스니펫들이 모든 Next.js 앱을 위한 견고하고 안전하며 현대적인 인증 기반을 형성합니다.

## 제4장: 점입가경 - 내 앱에 귀신이 들렸나! 👻

리디렉션 루프 문제를 해결하고 나니(이것도 useRef와 신중한 useEffect 의존성 관리라는 긴 이야기가 있지만), 더 사악한 문제가 나타났습니다. 앱이 그냥... 죽어버리는 것이었죠. 잠시 잘 작동하다가 브라우저 탭이 완전히 닫혀버렸습니다. 최악은, 브라우저가 너무 빨리 닫혀서 제 소중한 console.log 메시지들이 전부 사라진다는 점이었습니다. 저는 장님 비행을 하고 있었죠.

이것이 전환점이었습니다. 디버깅 도구가 사라졌을 때, 어떻게 문제를 해결해야 할까요?

**제 해결책**: 브라우저가 입을 닫았다면, 서버가 말하게 만들자. 저는 작고 투박한 서버 사이드 로깅 시스템을 구축했습니다.

아이디어는 간단했습니다:

1. 클라이언트 앱이 모든 중요한 로그(특히 Keycloak 관련)를 수집한다.
2. 몇 초마다 로그를 묶어서 Next.js 서버의 새로운 API 엔드포인트로 보낸다.
3. 서버는 이 로그들을 디스크의 파일에 기록한다.

이제 브라우저 탭이 장렬하게 전사하더라도, 로그는 서버에 안전하게 남아 저를 기다리고 있을 것이었습니다. 이것이 제가 한 일 중 가장 중요한 결정이었고, 다시 불을 밝혀주었죠.

## 제5장: 탐정 놀이 - 단서를 찾아서 🕵️‍♀️

서버 사이드 로거가 잘 돌아가자, 마침내 증거를 확보할 수 있었습니다. 사용자에게 앱이 다운될 때까지 사용해달라고 부탁한 뒤, 로그 파일을 파헤치기 시작했습니다.

발견한 것은... 이상했습니다. 단 한 명의 사용자에게서 몇 분 만에 8개가 넘는 서로 다른 세션 ID가 생성되고 있었습니다. 페이지가 새로고침되거나 다운될 때마다, 제 로깅 코드가 새로운 세션 ID를 만들고 있었던 거죠.

그리고 제 로그에 영리하게 추가해 둔 메모리 보고서를 보게 되었습니다.

```json
{
  "timestamp": "2025-08-01T07:28:00.100Z",
  "level": "critical",
  "message": "[Keycloak] 초기화 완료.",
  "memory": { "used": 180, "total": 200, "percentage": 90 }
},
{
  "timestamp": "2025-08-01T07:28:00.102Z",
  "level": "critical",
  "message": "페이지가 언로드되려고 함 - 크래시 감지됨"
}
```

앱의 메모리 사용량이 90-95%까지 치솟았고, Keycloak 초기화가 끝난 지 단 몇 밀리초 만에 다운되고 있었습니다.

**"아하!" 하는 순간**: 이건 전통적인 의미의 메모리 누수가 아니었습니다. 바로 세션 증식(session proliferation) 문제였죠. 그 유령 세션 하나하나가 백그라운드에서 실행되는 완전한 Keycloak 인스턴스였고, 메모리를 잡아먹고 있었던 겁니다. 제 앱에 귀신이 들린 게 아니라, 자기 자신의 복제본들에게 질식당하고 있었던 거죠!

## 제6장: 대대적인 수정 그리고 승리! 🏆

적을 알았으니, 싸울 수 있었습니다. 저는 다각적인 공격을 개시했습니다.

### 1. 영속적인 세션 ID

로거를 가장 먼저 손봤습니다. 매번 새로운 세션 ID를 만드는 대신, sessionStorage에서 먼저 찾아보도록 만들었습니다. ID가 있으면 재사용하도록 했죠. 간단하지만 효과적이었습니다.

**변경 전**: `this.sessionId = generateNewId();`

**변경 후**: `this.sessionId = getFromSessionStorage() || generateNewId();`

### 2. Keycloak 세션 관리 길들이기

저는 제멋대로인 세션 로직으로 Keycloak을 이겨보려 했습니다. 항복했죠. 라이브러리의 기본 기능인 `onLoad: "check-sso"`로 돌아가, 메모리를 많이 먹는 iframe 체크를 비활성화하는 등 올바른 설정에 집중했습니다.

### 3. 더 똑똑해진 토큰 갱신

토큰 갱신이 너무 잦다는 것을 깨달았습니다. 주기를 늘리고, 더 중요하게는 안전장치를 추가했습니다: "만약 메모리 사용량이 90%를 넘으면, 토큰 갱신을 시도조차 하지 말고 그냥 만료시켜서 재로그인하게 만들자."

### 4. 내 뒷정리는 스스로

적절한 정리(cleanup) 함수들을 추가했습니다. 사용자가 로그아웃하거나 컴포넌트가 언마운트될 때, 모든 타이머를 명시적으로 제거하고 Keycloak에게 스스로 정리하라고 지시했습니다.

결과는 하늘과 땅 차이였습니다. 앱은 안정화되었고, 메모리 사용량은 편안한 수준으로 떨어졌습니다. 더 이상 다운되지 않았습니다. 승리였습니다!

## 제7장: 최종적으로 완성된 영광의 아키텍처 ✨

모든 전투가 끝난 후, 저는 제가 자랑스러워할 만한 시스템을 갖게 되었습니다. 깔끔하고, 효율적이며, 안전했죠.

### 과거의 방식 (엉망진창):

❌ 두 개의 상충하는 인증 시스템 (내 커스텀 로직 vs Keycloak).  
❌ Keycloak 이중 초기화 에러.  
❌ 복잡한 서버 사이드 프록시 로직.  
❌ Next.js의 충돌하는 라우트 그룹.

### 새로운 방식 (꿈의 구조):

✅ Keycloak이 주도하는 단일하고 깔끔한 인증 플로우.  
✅ 더 이상의 초기화 충돌 없음.  
✅ 프론트엔드에서 백엔드로의 직접적이고 안전한 API 호출.  
✅ 깔끔한 책임 분리: Keycloak은 인증(당신이 누구인지)을, 우리 내부 서비스는 인가(당신이 무엇을 할 수 있는지)를 처리.  
✅ 간단하고 예측 가능한 라우팅 구조.

## 이 퀘스트를 통해 내가 배운 것

이 프로젝트는 롤러코스터 같았지만, 정말 많은 것을 가르쳐 주었습니다.

### ➡️ **직접 부딪히는 것을 두려워하지 마세요**

문서를 읽는 것과 실제 구현과 씨름하는 것은 차원이 다른 배움을 줍니다.

### ➡️ **도구가 말을 듣지 않으면, 더 나은 도구를 만드세요**

서버 사이드 로거는 프로젝트를 구한 간단한 아이디어였습니다.

### ➡️ **라이브러리를 믿되, 현명하게 설정하세요**

보통 Keycloak-js 같은 라이브러리에는 올바른 도구들이 있지만, 내 특정 상황에 맞게 사용하는 법을 이해해야 합니다.

### ➡️ **승리를 자축하세요!**

몇 주간의 고생 끝에 안정적인 메모리 그래프와 부드럽게 돌아가는 앱을 봤을 때, 제 개발 경력에서 가장 만족스러운 순간 중 하나였습니다.

## 예방 팁

### ✅ **이렇게 하세요**

- 복잡한 클라이언트 문제를 디버깅할 때 서버 사이드 로깅을 구축하세요
- SPA에는 PKCE를 사용하세요 - 올바른 보안 모델입니다
- 인증 라이브러리에 적절한 정리 함수를 구현하세요
- 인증 플로우 중 메모리 사용량을 모니터링하세요
- 개발 시나리오뿐만 아니라 실제 사용자로 테스트하세요

### ❌ **이렇게 하지 마세요**

- 확립된 인증 라이브러리를 뛰어넘으려고 시도하지 마세요
- 개발 중 메모리 사용 패턴을 무시하지 마세요
- 인증 플로우에서 적절한 에러 처리를 건너뛰지 마세요
- 인증이 프로덕션에서 개발과 똑같이 작동할 것이라고 가정하지 마세요
- 적절한 세션 관리를 구현하는 것을 잊지 마세요

## 리소스

- [PKCE RFC 7636](https://tools.ietf.org/html/rfc7636)
- [Keycloak 문서](https://www.keycloak.org/documentation)
- [Next.js 인증](https://nextjs.org/docs/authentication)
- [브라우저 기반 앱을 위한 OAuth 2.0](https://tools.ietf.org/html/draft-ietf-oauth-browser-based-apps)

---

_이 프로젝트는 롤러코스터 같았지만, 인증, 디버깅, 그리고 올바른 도구를 만드는 것의 중요성에 대해 정말 많은 것을 가르쳐 주었습니다. 핵심은 단순히 PKCE와 Keycloak을 구현하는 것이 아니라, 그것들이 어떻게 함께 작동하는지 이해하고 그 주변에 견고한 시스템을 구축하는 것이었습니다._

_그러니 만약 당신도 자신만의 코딩 용과 싸우고 있다면, 포기하지 마세요. 해답은 종종 제대로 된 로그 메시지 하나만 찾으면 나올 수 있습니다. 즐거운 코딩 하세요!_
